name: Build generate push
permissions:
  contents: read
on: [push]
jobs:
  list-modules:
    runs-on: ubuntu-latest
    outputs:
      dir: ${{ steps.set-dirs.outputs.dir }}
      # We force 'changed' to true if the commit message contains [run-all]
      changed: ${{ contains(github.event.head_commit.message, '[run-all]') || steps.changed-files.outputs.any_changed }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0 # Fetch all history to ensure we can find all go.mod files

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v47
        with:
          dir_names: true
          dir_names_exclude_current_dir: true
          files_ignore: .github/**

      - name: Determine modules to run
        id: set-dirs
        run: |
          # Check if the commit message contains [run-all]
          IF_RUN_ALL="${{ contains(github.event.head_commit.message, '[run-all]') }}"
          
          if [ "$IF_RUN_ALL" = "true" ]; then
            echo "Force running all modules due to [run-all] in commit message"
            # Find all directories containing a go.mod file
            modules=$(find . -name "go.mod" -exec dirname {} \;)
          else
            # Original logic: only modules with changed files
            modules=$(for changed_dir in ${{ steps.changed-files.outputs.all_changed_files }}; do
              # Ensure the directory exists before running go list
              if [ -d "./$changed_dir" ]; then
                echo $(cd ./$changed_dir && go list -f '{{.Module.Dir}}' "./..." 2>/dev/null)
              fi
            done | sort -u)
          fi

          # Format modules as a JSON array for the matrix
          # 1. sed: remove leading './'
          # 2. cut: extract everything before the first '/' (the root folder)
          # 3. jq: filter out empty strings and ensure unique values
          dir=$(echo "$modules" | sed 's|^\./||' | cut -d'/' -f1 | jq -R -s -c 'split("\n") | map(select(length > 0)) | unique')
          
          echo "dir=$dir" >> $GITHUB_OUTPUT
          echo "Selected modules: $dir"

  build-modules:
    # This will now trigger if files changed OR if [run-all] was used
    if: needs.list-modules.outputs.changed == 'true'
    runs-on: ubuntu-latest
    needs: [list-modules]
    continue-on-error: true
    strategy:
      max-parallel: 5
      matrix:
        dir: ${{ fromJson(needs.list-modules.outputs.dir) }}
    steps:
      - uses: actions/checkout@v6
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: "1.24"
          cache-dependency-path: ${{ matrix.dir }}/go.mod
          # Force a fresh cache if [run-all] is present (optional)
          cache: ${{ !contains(github.event.head_commit.message, '[run-all]') }}

      - name: Start lib
        run: echo Building ${{ matrix.dir }}

      - name: Build
        run: make all DIR=${{ matrix.dir }}

        # Cache the golangci-lint binary
      - name: Cache golangci-lint
        id: cache-lint
        uses: actions/cache@v4
        with:
          path: ~/go/bin/golangci-lint
          key: ${{ runner.os }}-golangci-lint
          
      - name: Lint install
        if: steps.cache-lint.outputs.cache-hit != 'true'
        run: make lint_install

      - name: Lint
        run: make lint DIR=${{ matrix.dir }} 

      - name: Test
        if: ${{ github.ref != 'main' }}
        run: make test DIR=${{ matrix.dir }} 
      
      - name: Test Process Coverage Badges
        # if: ${{ github.ref == 'main' }}
        shell: bash
        env:
          GIST_PAT: ${{ secrets.GIST_PAT }}
          GIST_ID: ${{ secrets.DYNAMIC_TEST_COVERAGE_GIST_ID }}
        run: |
          DIR="${{ matrix.dir }}"
          ROOT_DIR="$(pwd)"
  
          # Function to process a single module's coverage and badge
          process_coverage() {
            local target_dir=$1
            local coverage_file=$2
            local label_name=$3
            local filename=$4
            echo "target_dir: '$target_dir' , coverage_file: '$coverage_file' , label_name: '$label_name' , filename: '$filename'"
  
            cd $target_dir

            # 1. Extract Coverage
            if [ -f "$coverage_file" ]; then

              local cov=$(go tool cover -func="$coverage_file" | grep total | awk '{print $3}' | tr -dc '0-9.')
              echo "Coverage for $label_name: $cov%"
  
              # 2. Determine Color
              local color="red"
              if (( $(echo "$cov >= 90" | bc -l) )); then color="green"
              elif (( $(echo "$cov >= 70" | bc -l) )); then color="yellow"
              fi
  
              # 3. Update Gist using the Badge Action logic via Curl (or simple JSON post)
              # Since the Action step can't be looped, we manually create the JSON for the Gist
              # If you prefer the Action, see the alternative below.
              echo "{\"schemaVersion\":1,\"label\":\"$label_name\",\"message\":\"$cov%\",\"color\":\"$color\"}" > badge.json
                
              # Use GitHub CLI (installed on all runners) to update the gist
              gh gist edit "$GIST_ID" -f "$filename=badge.json"

            else
              echo "Warning: Coverage file $coverage_file not found."
            fi

            cd $ROOT_DIR
          }
  
          # Run tests with coverage
          make test_cover DIR=${{ matrix.dir }} 

          if [[ "$DIR" == "scenarios" ]]; then
            # Loop through all subdirectories in scenarios
            for sub in scenarios/*/; do
              sub_name=$(basename "$sub")
              process_coverage "scenarios/$sub_name" "../../.build/${sub_name}.scenarios.coverage.out" "Module $sub_name" "$sub_name-scenarios-coverage.json"
            done
          else
            # Standard root module
            process_coverage "$DIR" "../.build/${DIR}.coverage.out" "Module $DIR" "$DIR-coverage.json"
          fi
        
  # this step is needed for GH step validation to verify all build steps succeeded
  build-success:
    runs-on: ubuntu-latest
    needs: [build-modules]
    continue-on-error: false
    steps:
      - name: Success
        run: echo ok
